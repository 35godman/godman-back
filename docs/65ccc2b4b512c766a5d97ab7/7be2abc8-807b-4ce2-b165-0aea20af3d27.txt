Opens in a new window Opens an external website Opens an external website in a
new window
<!---->Close this dialog<!---->
This website utilizes technologies such as cookies to enable essential site
functionality, as well as for analytics, personalization, and targeted
advertising purposes. To learn more, view the following link:



<!---->Close Cookie Preferences<!---->


v1v2

--------------------------------------------------------------------------------

Guides

v2

Ctrl+K
Understanding cost
All
Guides
Reference
Pages

START TYPING TO SEARCH…


GETTING STARTED

 * 
 * 
 * 
 * 
 * 


ORGANIZATIONS

 * 
 * * 
   * 
   * 
   * 
   * 
 * * 
   * 
   * 


PROJECTS

 * 
 * 
 * 
 * 
 * 


INDEXES

 * 
 * 
 * 
 * 
 * 
 * 
 * 


DATA

 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * * 
   * 
   * 
   * 
 * * 
   * 


OPERATIONS

 * 
 * 
 * 
 * 
 * 


INTEGRATIONS

 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 


REFERENCE

 * 
 * 
 * 
 * 
 * 
 * 


SUPPORT

 * 
 * 
 * 


UNDERSTANDING COST



This page describes how costs are incurred in Pinecone for both serverless and
pod-based indexes.


SERVERLESS INDEXES


> ℹ️
> 
> NOTE
> 
> Serverless indexes are in public preview. Check and test thoroughly before
> using them in production.

With , you don't configure or manage any compute or storage resources. Instead,
based on a , serverless indexes scale automatically based on usage, and you pay
only for the amount of data stored and operations performed, based on three
usage metrics:

 * Read units (RUs): Read units measure the resources consumed by read
   operations such as query, fetch, and list.

 * Write units (WUs): Write units measure the resources used by write operations
   such as upsert, update, and delete.

 * Storage: You're billed for the size of an index on a per-GB rate, with the
   exact rate of each unit determined based on your cloud provider, region, and
   plan (see our ).


READ UNITS

Read operations consume read units (RUs). Read units measure the compute, I/O,
and network resources used during the read process.

The following operations consume RUs:

 * 
 * 
 * 

The number of RUs used by a specific request is always included in its response.
For a demonstration of how to use read units to inspect read costs, see .


FETCH

A fetch request uses 1 RU for every 10 fetched records.

# of fetched recordsRU usage10150510711

Specifying a non-existent ID or adding the same ID more than once does not
increase the number of RUs used. However, a fetch request will always use at
least 1 RU.


QUERY

The number of RUs used by a query is proportional to the following factors:

 * Record count: The number of vectors contained in the target index. Only
   vectors stored in the relevant namespace are used.
 * Record size: Higher dimensionality or larger metadata increases the size of
   each scanned vector.

Because serverless indexes organize vectors in similarity-based clusters, only a
fraction of each index will be read for each query. The number of RUs a query
uses therefore increases much more slowly than the index size.

The following table contains the RU cost of a query at different namespace sizes
and record dimensionality, assuming an average metadata size around 500 bytes:

Records per namespaceDimension=384Dimension=768Dimension=1536100,0005 RUs5 RUs6
RUs1,000,0006 RUs10 RUs18 RUs10,000,00018 RUs32 RUs59 RUs

Scanning a namespace has a minimal cost of 5 RUs.

When either include_metadata or include_values are specified, an internal fetch
call retrieves the full record values for the IDs returned in the initial scan.
This stage consumes RUs equal to a matching fetch call - 1 RU per 10 records in
the result set.

TopK valueAdditional RUs usedTopK=51TopK=101TopK=505


LIST

List has a fixed cost of 1 RU per call, with an additional 1 RU per paginated
call.


WRITE UNITS

Write operations consume write units (WUs). Write units measure the storage and
compute resources used to persist a record, make it available for querying, and
update the clustered index to reflect its addition.

The following operations consume WUs:

 * 
 * 
 * 


UPSERT

The number of WUs used by an upsert request is proportional to the total size of
records it writes and/or modifies, with a minimum of 1 WU.

The following table contains the WU cost of an upsert request at different batch
sizes and record dimensionality, assuming an average metadata size around 500
bytes:

Records per batchDimension=384Dimension=768Dimension=153613 WUs4 WUs7 WUs1030
WUs40 WUs70 WUs100300 WUs400 WUs700 WUs


UPDATE

The number of WUs used when updating a record is proportional to the total size
of the new or previous version of the record, whichever is larger, with a
minimum of 1 WU.

The following table contains the WU cost of an update request at different
dimensionalities and metadata sizes, with WUs based on the new or previous
metadata size, whichever is larger:

DimensionPrevious metada sizeNew metadata sizeWUs768400 bytes500 bytes4
WUs1536400 bytes500 bytes7 WUs15364000 bytes2000 bytes11 WUs


DELETE

The number of WUs used by a delete request is proportional to the total size of
records it deletes, with a minimum of 1 WU.

The following table contains the WU cost of a delete request at different batch
sizes and record dimensionality, assuming an average metadata size around 500
bytes:

Records per batchDimension=384Dimension=768Dimension=153613 WUs4 WUs7 WUs1030
WUs40 WUs70 WUs100300 WUs400 WUs700 WUs

Specifying a non-existent ID or adding the same ID more than once does not
increase WU use.


DELETING AN ENTIRE NAMESPACE

Deleting an entire namespace using the deleteAll flag always consumes 1 WU.


STORAGE

The size of an index is defined as the total size of its vectors across all
namespaces. The size of a single vector is defined as the sum of three
components:

 * ID size
 * Embedding size (equal to 4 times the vector’s dimensions)
 * Total metadata size (equal to the total size of all metadata fields)

The following table demonstrates a typical index size at different vector counts
and dimensionality:

Records per namespaceDimension=384Dimension=768Dimension=1536100,0000.20 GB0.35
GB0.66 GB1,000,0002.00 GB3.50 GB6.60 GB10,000,00020.00 GB35.00 GB66.00 GB


MONITORING USAGE

 * : In the Pinecone console, you can track usage and performance metrics for
   each index.
 * : The response to read operations like query, fetch, and list include the
   number of read units consumed.


POD-BASED INDEXES


COST CALCULATION

For each , billing is determined by the per-minute price per pod and the number
of pods the index uses, regardless of index activity. The per-minute price
varies by pod type, pod size, account plan, and cloud region.

Total cost depends on a combination of factors:

 * Pod type. Each has different per-minute pricing.
 * Number of pods. This includes replicas, which duplicate pods.
 * Pod size. Larger pod sizes have proportionally higher costs per minute.
 * Total pod-minutes. This includes the total time each pod is running, starting
   at pod creation and rounded up to 15-minute increments.
 * Cloud provider. The cost per pod-type and pod-minute varies depending on the
   cloud provider you choose for your project.
 * Collection storage. Collections incur costs per GB of data per minute in
   storage, rounded up to 15-minute increments.
 * Plan. The free plan incurs no costs; the Standard or Enterprise plans incur
   different costs per pod-type, pod-minute, cloud provider, and collection
   storage.

The following equation calculates the total costs accrued over time:

(Number of pods) * (pod size) * (number of replicas) * (minutes pod exists) * (pod price per minute) 
+ (collection storage in GB) * (collection storage time in minutes) * (collection storage price per GB per minute)


To see a calculation of your current usage and costs, see the in the Pinecone
console.


PRICING

For pod-based index pricing rates, see our .


EXAMPLE

While our pricing page lists rates on an hourly basis for ease of comparison,
this example lists prices per minute, as this is how Pinecone calculates
billing.

An example application has the following requirements:

 * 1,000,000 vectors with 1536 dimensions
 * 150 queries per second with top_k = 10
 * Deployment in an EU region
 * Ability to store 1GB of inactive vectors

, the organization chooses to configure the project to use the Standard billing
plan to host one p1.x2 pod with three replicas and a collection containing 1 GB
of data. This project runs continuously for the month of January on the Standard
plan. The components of the total cost for this example are given in Table 1
below:

Table 1: Example billing components

Billing componentValueNumber of pods1Number of replicas3Pod sizex2Total pod
count6Minutes in January44,640Pod-minutes (pods * minutes)267,840Pod price per
minute$0.0012Collection storage1 GBCollection storage minutes44,640Price per
storage minute$0.00000056

The invoice for this example is given in Table 2 below:

Table 2: Example invoice

ProductQuantityPrice per unitChargeCollections44,640$0.00000056$0.025P2 Pods
(AWS)0$0.00P2 Pods (GCP)0$0.00S1 Pods0$0.00P1 Pods267,840$0.0012$514.29

Amount due $514.54


COST CONTROLS

Pinecone offers tools to help you understand and control your costs.

 * Monitoring usage. You can use the in the Pinecone console to monitor your
   Pinecone usage and costs as these accrue.

 * Pod limits. For pod-based indexes, project owners can across all indexes in
   the project. The default pod limit is 5.


SEE ALSO

 * 

 * 

Updated 6 days ago

--------------------------------------------------------------------------------


Did this page help you?
Yes
No
 * 
 * * * 
     * 
     * 
     * 
   * * 
     * 
     * 
   * 
   * 







Pinecone [https://pinecone.io/images/pinecone-white.svg]
 * 
 * 
 * 
 * 
 * 
 * 

© Pinecone Systems, Inc. | San Francisco, CA | | | | | |

Pinecone is a registered trademark of Pinecone Systems, Inc.


