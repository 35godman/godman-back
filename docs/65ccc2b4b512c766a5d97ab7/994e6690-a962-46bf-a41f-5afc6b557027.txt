Opens in a new window Opens an external website Opens an external website in a
new window
<!---->Close this dialog<!---->
This website utilizes technologies such as cookies to enable essential site
functionality, as well as for analytics, personalization, and targeted
advertising purposes. To learn more, view the following link:



<!---->Close Cookie Preferences<!---->


v1v2

--------------------------------------------------------------------------------

Guides

v2

Ctrl+K
Filtering with metadata
All
Guides
Reference
Pages

START TYPING TO SEARCH…


GETTING STARTED

 * 
 * 
 * 
 * 
 * 


ORGANIZATIONS

 * 
 * * 
   * 
   * 
   * 
   * 
 * * 
   * 
   * 


PROJECTS

 * 
 * 
 * 
 * 
 * 


INDEXES

 * 
 * 
 * 
 * 
 * 
 * 
 * 


DATA

 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * * 
   * 
   * 
   * 
 * * 
   * 


OPERATIONS

 * 
 * 
 * 
 * 
 * 


INTEGRATIONS

 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 


REFERENCE

 * 
 * 
 * 
 * 
 * 
 * 


SUPPORT

 * 
 * 
 * 


FILTERING WITH METADATA



You can limit your vector search based on metadata. Pinecone lets you attach
metadata key-value pairs to vectors in an index, and specify filter expressions
when you query the index.

Searches with metadata filters retrieve exactly the number of nearest-neighbor
results that match the filters. For most cases, the search latency will be even
lower than unfiltered searches.

Searches without metadata filters do not consider metadata. To combine keywords
with semantic search, see .

For more background information on metadata filtering, see: .


SUPPORTED METADATA TYPES

You can associate a metadata payload with each vector in an index, as key-value
pairs in a JSON object where keys are strings and values are one of:

 * String
 * Number (integer or floating point, gets converted to a 64 bit floating point)
 * Booleans (true, false)
 * List of String


> ⚠️
> 
> WARNING
> 
> Null metadata values are not supported. Instead of setting a key to hold a
> null value, we recommend you remove that key from the metadata payload.

For example, the following would be valid metadata payloads:

JSON
{
    "genre": "action",
    "year": 2020,
    "length_hrs": 1.5
}

{
    "color": "blue",
    "fit": "straight",
    "price": 29.99,
    "is_jeans": true
}



MANAGING HIGH-CARDINALITY IN POD-BASED INDEXES

For pod-based indexes, Pinecone indexes all metadata by default. When metadata
contains many unique values, pod-based indexes will consume significantly more
memory, which can lead to performance issues, pod fullness, and a reduction in
the number of possible vectors that fit per pod.

To avoid indexing high-cardinality metadata that is not needed for filtering,
use , which lets you specify which fields need to be indexed and which do not.

Serverless indexes are not affected by high-cardinality metadata.


SUPPORTED METADATA SIZE

Pinecone supports 40kb of metadata per vector.


METADATA QUERY LANGUAGE


> ℹ️
> 
> NOTE
> 
> Pinecone's filtering query language is based on . We
> currently support a subset of those selectors.

The metadata filters can be combined with AND and OR:

 * $eq - Equal to (number, string, boolean)
 * $ne - Not equal to (number, string, boolean)
 * $gt - Greater than (number)
 * $gte - Greater than or equal to (number)
 * $lt - Less than (number)
 * $lte - Less than or equal to (number)
 * $in - In array (string or number)
 * $nin - Not in array (string or number)


USING ARRAYS OF STRINGS AS METADATA VALUES OR AS METADATA FILTERS

A vector with metadata payload...

JSON
{ "genre": ["comedy", "documentary"] }


...means the "genre" takes on both values.

For example, queries with the following filters will match the vector:

JSON
{"genre":"comedy"}

{"genre": {"$in":["documentary","action"]}}

{"$and": [{"genre": "comedy"}, {"genre":"documentary"}]}


Queries with the following filter will not match the vector:

JSON
{ "$and": [{ "genre": "comedy" }, { "genre": "drama" }] }


And queries with the following filters will not match the vector because they
are invalid. They will result in a query compilation error:

# INVALID QUERY:
{"genre": ["comedy", "documentary"]}


# INVALID QUERY:
{"genre": {"$eq": ["comedy", "documentary"]}}



INSERTING METADATA INTO AN INDEX

Metadata can be included in upsert requests as you insert your vectors.

For example, here's how to insert vectors with metadata representing movies into
an index:

PythonJavaScriptcurl
from pinecone import Pinecone

pc = Pinecone(api_key="YOUR_API_KEY")
index = pc.Index("pinecone-index")

index.upsert(
  vectors=[
    {
      "id": "A", 
      "values": [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1], 
      "metadata": {"genre": "comedy", "year": 2020}
    },
    {
      "id": "B", 
      "values": [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2],
      "metadata": {"genre": "documentary", "year": 2019}
    },
    {
      "id": "C", 
      "values": [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],
      "metadata": {"genre": "comedy", "year": 2019}
    },
    {
      "id": "D", 
      "values": [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4],
      "metadata": {"genre": "drama"}
    }
  ]
)


import { Pinecone } from '@pinecone-database/pinecone'

const pc = new Pinecone({ apiKey: "YOUR_API_KEY" })
const index = pc.index("pinecone-index")

const records = [
    {
      id: 'A',
      values: [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
      metadata: { genre: "comedy", year: 2020 },
    },
    {
      id: 'B',
      values: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2],
      metadata: { genre: "documentary", year: 2019 },
    },
    {
      id: 'C',
      values: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],
      metadata: { genre: "comedy", year: 2019 },
    },
    {
      id: 'D',
      values: [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4],
      metadata: { genre: "drama" },
    }
]

await index.upsert(records);


# The `POST` requests below uses the unique endpoint for an index.
# See https://docs.pinecone.io/docs/get-index-endpoint for details.
PINECONE_API_KEY="YOUR_API_KEY"
INDEX_HOST="INDEX_HOST"

curl -X POST "https://$INDEX_HOST/vectors/upsert" \
  -H "Api-Key: $PINECONE_API_KEY" \
  -H 'Content-Type: application/json' \
  -d '{
    "vectors": [
      {
        "id": "A",
        "values": [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
        "metadata": {"genre": "comedy", "year": 2020}
      },
      {
        "id": "B",
        "values": [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2],
        "metadata": {"genre": "documentary", "year": 2019}
      },
      {
        "id": "C",
        "values": [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],
        "metadata": {"genre": "comedy", "year": 2019}
      },
      {
        "id": "D",
        "values": [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4],
        "metadata": {"genre": "drama"}
      }
    ]
  }'



QUERYING AN INDEX WITH METADATA FILTERS

Metadata filter expressions can be included with queries to limit the search to
only vectors matching the filter expression.

For example, we can search the previous movies index for documentaries from the
year 2019. This also uses the include_metadata flag so that vector metadata is
included in the response.


> ⚠️
> 
> WARNING
> 
> For optimal performance, when querying pod-based indexes with top_k over 1000,
> avoid returning vector data (include_values=True) or metadata
> (include_metadata=True).

PythonJavaScriptcurl
from pinecone import Pinecone

pc = Pinecone(api_key="YOUR_API_KEY")
index = pc.Index("pinecone-index")

index.query(
    vector=[0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
    filter={
        "genre": {"$eq": "documentary"},
        "year": 2019
    },
    top_k=1,
    include_metadata=True
)

# Returns:
# {'matches': [{'id': 'B',
#               'metadata': {'genre': 'documentary', 'year': 2019.0},
#               'score': 0.0800000429,
#               'values': []}],
#  'namespace': ''}


import { Pinecone } from '@pinecone-database/pinecone'

const pc = new Pinecone({ apiKey: "YOUR_API_KEY" })
const index = pc.index("pinecone-index")

const queryResponse = await index.query({
  vector: [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
  filter: { genre: { $in: ["comedy", "documentary", "drama"] } },
  topK: 1,
  includeMetadata: true,
});
console.log(queryResponse.data);
// Returns:
// {'matches': [{'id': 'B',
//               'metadata': {'genre': 'documentary', 'year': 2019.0},
//               'score': 0.0800000429,
//               'values': []}],
//  'namespace': ''}


# The `POST` requests below uses the unique endpoint for an index.
# See https://docs.pinecone.io/docs/get-index-endpoint for details.
PINECONE_API_KEY="YOUR_API_KEY"
INDEX_HOST="INDEX_HOST"

curl -i -X POST "https://$INDEX_HOST/query" \
  -H 'Api-Key: $PINECONE_API_KEY' \
  -H 'Content-Type: application/json' \
  -d '{
    "vector": [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
    "filter": {"genre": {"$in": ["comedy", "documentary", "drama"]}},
    "topK": 1,
    "includeMetadata": true
  }'

# Output:
# {
#       "matches": [
#         {
#           "id": "B",
#           "score": 0.0800000429,
#           "values": [],
#           "metadata": {
#             "genre": "documentary",
#             "year": 2019
#           }
#         }
#       ],
#       "namespace": ""
#     }



MORE EXAMPLE FILTER EXPRESSIONS

A comedy, documentary, or drama:

JSON
{
  "genre": { "$in": ["comedy", "documentary", "drama"] }
}


A drama from 2020:

JSON
{
  "genre": { "$eq": "drama" },
  "year": { "$gte": 2020 }
}


A drama from 2020 (equivalent to the previous example):

JSON
{
  "$and": [{ "genre": { "$eq": "drama" } }, { "year": { "$gte": 2020 } }]
}


A drama or a movie from 2020:

JSON
{
  "$or": [{ "genre": { "$eq": "drama" } }, { "year": { "$gte": 2020 } }]
}



DELETING VECTORS BY METADATA FILTER


> ℹ️
> 
> NOTE
> 
> Serverless and starter indexes do not support deleting by metadata. For
> serverless indexes, you can instead.

To use metadata values to select vectors to be deleted, pass a metadata filter
expression to the delete operation. This deletes all vectors matching the
metadata filter expression.

Example

This example deletes all vectors with genre "documentary" and year 2019 from an
index.

PythonJavaScriptcurl
from pinecone import Pinecone

pc = Pinecone(api_key="YOUR_API_KEY")
index = pc.Index("pinecone-index")

index.delete(
    filter={
        "genre": {"$eq": "documentary"},
        "year": 2019
    }
)


import { Pinecone } from '@pinecone-database/pinecone'

const pc = new Pinecone({ apiKey: "YOUR_API_KEY" })
const index = pc.index("pinecone-index")

await index.deleteMany({
  genre: { $eq: "documentary" },
  year: 2019,
});


# The `POST` requests below uses the unique endpoint for an index.
# See https://docs.pinecone.io/docs/get-index-endpoint for details.
PINECONE_API_KEY="YOUR_API_KEY"
INDEX_HOST="INDEX_HOST"

curl -i -X POST "https://$INDEX_HOST/vectors/delete" \
  -H 'Api-Key: $PINECONE_API_KEY' \
  -H 'Content-Type: application/json' \
  -d '{
    "filter": {"genre": {"$in": ["comedy", "documentary", "drama"]}}
  }'


Updated 30 days ago

--------------------------------------------------------------------------------


Did this page help you?
Yes
No
 * 
 * * * 
   * 
   * * 
   * 
   * * 
   * 







Pinecone [https://pinecone.io/images/pinecone-white.svg]
 * 
 * 
 * 
 * 
 * 
 * 

© Pinecone Systems, Inc. | San Francisco, CA | | | | | |

Pinecone is a registered trademark of Pinecone Systems, Inc.


